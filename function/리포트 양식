# Day - 6 (리포트 )

### 학습 날짜
2020-12-28(월)

### 학습시간
14:00 ~ 20:00(자가)

### 학습 범위 및 주제
memset, split

### 동료 학습 방법
네이버 라인웍스 및 디스코드를 통한 질문 및 답변

### 학습 목표
- memset의 입력에 따른 결과값을 메모리 단위에서의 작동 방식 이해

### 학습 내용
#### memset (구현 시간 5m)
```c
void *memset(void *s, int c, size_t n)
```

memset 함수는 메모리를 입력 받은 값으로 초기화하는 기능이다.<br/>
입력받는 매개변수는 아래와 같다.<br/>

###### 1. s : 초기화 시킬 메모리의 시작 주소
###### 2. c : 초기화 값
###### 3. n : 초기화 시킬 메모리의 길이(바이트 수)

매개변수를 이용해 초기화를 진행한 뒤 초기화가 완료된 s의 주소를 다시 반환하게된다.<br/>

memset은 메모리를 1byte씩 읽고 초기화 과정을 진행하며 이 과정에서 형변환을 필요로 한다.
```c
*((unsigned char *)s) = (unsigned char)c;
```
형변환이 unsigned char로 이루어지는 이유는 다음과 같다.

- void 형의 경우 다양한 형을 받을 수 있다.
- char 형이 1byte의 크기를 가진다.
- char 형의 경우 부호 비트를 고려한다.

즉, void 타입의 경우 다양한 형의 매개변수를 받을 수 있어 형에 상관없이 메모리를 읽고 초기화할 필요가 있다. 따라서, 1byte씩 읽고 쓰기위해 1byte 크기를 지닌 char형을 사용한다.

그렇다면 unsigned char와 char의 차이점에 대해 알아보자. 간단하게 설명하면 메모리를 읽는 방식의 차이로 char는 부호를 고려하고 unsigned char는 부호를 고려하지 않는다는 점이다. 아래 사진은 좀 더 가시적으로 설명하고 있다.<br/>
<p align="center">
  <img src = "https://user-images.githubusercontent.com/48250370/103212492-3e834880-494e-11eb-8f03-836c4b3e3489.png" width="600">
</p>

이미지참조 : https://www.geeksforgeeks.org/unsigned-char-in-c-with-examples/<br/>

사진에서 알 수 있듯이 char (signed char)의 경우 가장 앞 비트를 부호 비트로 사용하게 되어 결과적으로 -128 ~ 127의 범위를 갖게 된다. 반면, unsigned char의 경우 0~255의 범위를 갖게 된다.

### 입력값에 따른 결과값
##### 기본
```
s : aaaaa | c : 0 | n : 0,3
aaaaa
000aa
```
##### s의 범위를 넘어선 n 값이 들어온 경우
```
s : aaaaa | c : 0 | n : 7
00000.00 ('.' : 기존 s의 범위)
```
##### s가 NULL이 들어온 경우
```
s : NULL | c : - | n : -
segmentation fault
```
##### c가 정수형 타입의 범위를 넘어선 경우
```
s : - | c : 9223372036854775808 | n : -
compile error
```

### 주의사항
위의 결과값들은 입력받은 s의 타입이 (char &#42;)인 경우이다. 만약, s의 타입이 (int &#42;)라면 n이 0인 경우를 제외하고 의도하지 않은 결과가 출력된다.<br/>

memset 함수는 char 형 배열을 초기화하는 경우는 큰 상관은 없지만 int 형의 배열을 초기화하는 경우는 제약이 따른다.<br/>

### 개인 총평
man에 memset에 대한 간단한 설명들과 기본 형태 등은 나와있지만 특정 입력에 대한 결과값에 대해선 정리가 되어있지 않아 예외처리가 까다롭다고 생각된다. 구현했던 다른 함수들 또한 예외처리가 부족하여 틈틈이 입력값에 따른 결과값에 대해 정리할 필요성이 있다고 판단하였다.<br/>

memset 함수를 분석하며 unsigned char를 사용하는 이유에 대해 자세히 이해할 수 있었다. 또한, overflow와 underflow가 발생한 경우에 출력되는 결과값을 분석하며 메모리 수준에서의 작동 방식에 대해 이해할 수 있었다.<br/>

### 학습 계획
1. libft 구현 함수 예외처리 확인
